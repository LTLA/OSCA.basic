---
output:
  html_document
bibliography: ref.bib
---

# Marker gene detection {#marker-detection}

```{r setup, echo=FALSE, results="asis"}
library(rebook)
chapterPreamble()
```

## Motivation

To interpret our clustering results from Chapter \@ref(clustering), we identify the genes that drive separation between clusters.
These marker genes allow us to assign biological meaning to each cluster based on their functional annotation.
In the simplest case, we have _a priori_ knowledge of the marker genes associated with particular cell types, allowing us to treat the clustering as a proxy for cell type identity.
The same principle can be applied to discover more subtle differences between clusters (e.g., changes in activation or differentiation state) based on the behavior of genes in the affected pathways.

The most straightforward approach to marker gene detection involves testing for differential expression between clusters.
If a gene is strongly DE between clusters, it is likely to have driven the separation of cells in the clustering algorithm.
Several methods are available to quantify the differences in expression profiles between clusters and obtain a single ranking of genes for each cluster.
We will demonstrate some of these choices in this chapter using the 10X PBMC dataset:

```{r, results='asis', echo=FALSE}
extractFromPackage("tenx-unfiltered-pbmc4k.Rmd", package="OSCA.workflows",
    chunk="clustering", objects="sce.pbmc")
```

```{r}
sce.pbmc
```

## Scoring markers by pairwise comparisons

Our general strategy is to compare each pair of clusters and compute scores quantifying the differences in the expression distributions between clusters.
The scores for all pairwise comparisons involving a particular cluster are then consolidated into a single `DataFrame` for that cluster.
The `scoreMarkers()` function from `r Biocpkg("scran")` returns a list of `DataFrame`s where each `DataFrame` corresponds to a cluster and each row of the `DataFrame` corresponds to a gene.
In the `DataFrame` for cluster $X$, the columns contain the `self.average`, the mean log-expression in $X$;
`other.average`, the grand mean across all other clusters;
`self.detected`, the proportion of cells with detected expression in $X$;
`other.detected`, the mean detected proportion across all other clusters;
and finally, a variety of effect size summaries generated from all pairwise comparisons involving $X$.

```{r}
library(scran)
marker.info <- scoreMarkers(sce.pbmc, colLabels(sce.pbmc))
marker.info
colnames(marker.info[["1"]]) # statistics for marker 1.
```

For each cluster, we can then rank candidate markers based on one of these effect size summaries.
We demonstrate below with the mean AUC for cluster 1, which probably contains NK cells based on the top genes in Figure \@ref(fig:pbmc-scored-markers-1) (and no _CD3E_ expression).
The next section will go into more detail on the differences between the various columns.

```{r pbmc-scored-markers-1, fig.height=10, fig.width=8, fig.cap="Distribution of expression values across clusters for the top potential marker genes from cluster 1 in the PBMC dataset."}
chosen <- marker.info[["1"]]
ordered <- chosen[order(chosen$mean.AUC, decreasing=TRUE),]
head(ordered[,1:4]) # showing basic stats only, for brevity.

library(scater)
plotExpression(sce.pbmc, features=head(rownames(ordered)), 
    x="label", colour_by="label")
```

```{r, echo=FALSE}
# Also noting that CD3 is not highly expressed.
stopifnot(which("CD3E"==rownames(ordered)) > 10000)
stopifnot(all(c("GNLY", "NKG7") %in% head(rownames(ordered))))
```

We deliberately use pairwise comparisons rather than comparing each cluster to the average of all other cells.
The latter approach is sensitive to the population composition, which introduces an element of unpredictability to the marker sets due to variation in cell type abundances.
(In the worst case, the presence of one subpopulation containing a majority of the cells will drive the selection of top markers for every other cluster, pushing out useful genes that can distinguish between the smaller subpopulations.)
Moreover, pairwise comparisons naturally provide more information to interpret of the utility of a marker, e.g., by providing log-fold changes to indicate which clusters are distinguished by each gene (Section \@ref(obtaining-the-full-effects)).

## Available effect sizes

In the context of marker detection, the area under the curve (AUC) quantifies our ability to distinguish between two distributions in a pairwise comparison.
The AUC represents the probability that a randomly chosen observation from our cluster of interest is greater than a randomly chosen observation from the other cluster.
A value of 1 corresponds to upregulation, where all values of our cluster of interest are greater than any value from the other cluster;
a value of 0.5 means that there is no net difference in the location of the distributions;
and a value of 0 corresponds to downregulation.
The AUC is closely related to the $U$ statistic in the Wilcoxon ranked sum test (a.k.a., Mann-Whitney U-test).

```{r}
auc.only <- chosen[,grepl("AUC", colnames(chosen))]
auc.only[order(auc.only$mean.AUC,decreasing=TRUE),]
```

Cohen's $d$ is a standardized log-fold change where the difference in the mean log-expression between groups is scaled by the pooled standard deviation.
In other words, it is the number of standard deviations that separate the means of the two groups.
The interpretation is similar to the log-fold change; positive values indicate that the gene is upregulated in our cluster of interest, 
negative values indicate downregulation and values close to zero indicate that there is little difference.
Cohen's $d$ is roughly analogous to the $t$-statistic in Welch's two-sample $t$-test.

```{r}
cohen.only <- chosen[,grepl("logFC.cohen", colnames(chosen))]
cohen.only[order(cohen.only$mean.logFC.cohen,decreasing=TRUE),]
```

Finally, we also compute the log-fold change in the proportion of cells with detected expression between clusters.
This ignores any information about the magnitude of expression, only considering whether any expression is detected at all.
Again, positive values indicate that a greater proportion of cells express the gene in our cluster of interest compared to the other cluster.
Note that a pseudo-count is added to avoid undefined log-fold changes when no cells express the gene in either group.

```{r}
detect.only <- chosen[,grepl("logFC.detected", colnames(chosen))]
detect.only[order(detect.only$mean.logFC.detected,decreasing=TRUE),]
```

The AUC or Cohen's $d$ is usually the best choice for general purpose marker detection, as they are effective regardless of the magnitude of the expression values.
The log-fold change in the detected proportion is specifically useful for identifying binary changes in expression.
See Section XXX for more information about the practical differences between the effect sizes.

## Summarizing pairwise effects 

For each gene, our pairwise comparisons generate a large number of effect sizes that are relevant to each cluster.
Specifically, in a dataset with $N$ clusters, each cluster has $N-1$ values for any effect size described in the previous section.
To simplify interpretation, we summarize the set of effects for each cluster by computing the mean, median, minimum and maximum value across all comparisons involving that cluster.
Each summary statistic has a different interpretation when used for ranking:

- The most obvious summary statistic is the mean.
For cluster $X$, a large mean effect size (>0 for the log-fold changes, >0.5 for the AUCs) indicates that the gene is upregulated in $X$ compared to the average of the other groups.
In practice, a weighted mean is used where the effect size from any particular comparison is weighted according to the number of cells involved.
This ensures that statistics from comparisons with very few cells do not skew the summaries;
however, the weight is also capped beyond a "sufficient" number of cells (default 100), such that comparisons involving very large clusters do not dominate the calculated mean. 
- Another summary statistic is the median, where a large value indicates that the gene is upregulated in $X$ compared to most (>50%) other clusters.
The median provides greater robustness to outliers than the mean - this may or may not be desirable.
On one hand, it avoids an inflated effect size if only a minority of comparisons have large effects;
on the other hand, it will also overstate the effect size by ignoring a minority of comparisons that have opposing effects.
- The minimum value is an interesting summary for identifying upregulated genes, as a large value indicates that the gene is upregulated in $X$ compared to _all_ other clusters.
Ranking by the minimum effect is highly stringent as a large minimum can only be obtained if strong upregulation must be observed in every comparison between $X$ and another cluster.
Conversely, if the minimum is small (<0 for the log-fold changes, <0.5 for the AUCs), we can conclude that the gene is downregulated in $X$ compared to at least one other cluster.
- The maximum value is the least stringent summary for identifying upregulated genes, as a large value can be obtained if there is strong upregulation in $X$ compared to _any_ other cluster.
Conversely, if the maximum is small, we can conclude that the gene is downregulated in $X$ compared to all other clusters.
Both the minimum and maximum can also be helpful for diagnosing discrepancies between the mean and median, as the former is much more sensitive to the extremes than the latter.

```{r, echo=FALSE}
target <- "4"
```

Each of these summaries is computed for each effect size, for each gene, and for each cluster.
Our next step is to choose one of these summary statistics for one of the effect sizes and to use it to rank the rows of the `DataFrame`.
The choice of summary determines the stringency of the marker selection strategy, i.e., how many other clusters must we differ from?
For identifying upregulated genes, ranking by the minimum is the most stringent and the maximum is the least stringent;
the mean and median fall somewhere in between and are reasonable defaults for most applications.
The example below uses the median Cohen's $d$ to obtain a ranking of upregulated markers for cluster `r target` (Figure \@ref(fig:pbmc-scored-markers-again)), which probably contains monocytes.

```{r pbmc-scored-markers-again, fig.height=10, fig.width=8, fig.cap=sprintf("Distribution of expression values across clusters for the top potential marker genes from cluster %s in the PBMC dataset.", target)}
chosen <- marker.info[["4"]] # using another cluster, for some variety.
ordered <- chosen[order(chosen$median.logFC.cohen,decreasing=TRUE),]
head(ordered[,1:4]) # showing basic stats only, for brevity.
plotExpression(sce.pbmc, features=head(rownames(ordered)), 
    x="label", colour_by="label")
```

```{r, echo=FALSE}
# Higher CD14 than CD16.
stopifnot(which("CD14"==rownames(ordered)) < 50)
stopifnot(which("FCGR3A"==rownames(ordered)) > 500)
stopifnot(all(c("LYZ", "S100A9", "S100A8") %in% head(rownames(ordered))))
```

On some occasions, the minimum can be highly effective as it yields a concise set of highly cluster-specific markers. 
However, any gene that is expressed at the same level in two or more clusters will simply not be detected. 
This is likely to discard many interesting genes, especially if the clusters are finely resolved with weak separation.
To give a concrete example, consider a mixed population of CD4^+^-only, CD8^+^-only, double-positive and double-negative T cells.
Neither _Cd4_ or _Cd8_ would be detected as subpopulation-specific markers because each gene is expressed in two subpopulations such that the minimum effect would be small.

Our discussion above has focused mainly on potential markers that are upregulated in our cluster of interest, as these are the easiest to interpret and experimentally validate.
However, it also means that any cluster defined by downregulation of a marker will not contain that gene among the top features. 
This is occasionally relevant for subtypes or other states that are defined by low expression of particular genes. 
In such cases, focusing on upregulation may yield a disappointing set of markers,
and it may be worth examining some of the lowest-ranked genes to see if there is any consistent downregulation compared to other clusters.

```{r}
# Omitting the decreasing=TRUE to focus on negative effects.
ordered <- chosen[order(chosen$median.logFC.cohen),1:4]
head(ordered)
```

## Obtaining the full effects

For more complex questions, we may need to interrogate effect sizes from specific comparisons of interest.
To do so, we set `full.stats=TRUE` to obtain the effect sizes for all pairwise comparisons involving a particular cluster.
This is returned in the form of a nested `DataFrame` for each effect size type - 
in the example below, `full.AUC` contains the AUCs for the comparisons between cluster `r target` and every other cluster.

```{r}
marker.info <- scoreMarkers(sce.pbmc, colLabels(sce.pbmc), full.stats=TRUE)
chosen <- marker.info[["4"]]
chosen$full.AUC
```

Say we want to identify the genes that distinguish cluster 4 from other clusters with high _LYZ_ expression.
We subset `full.AUC` to the relevant comparisons and sort on the row means to obtain a ranking of up- and downregulated markers.
This allows us to easily characterize subtle differences between closely related clusters.

```{r}
lyz.high <- c("6", "8", "9", "14") # based on inspection of the previous Figure.
subset <- chosen$full.AUC[,lyz.high]
subset[order(rowMeans(as.matrix(subset)), decreasing=TRUE),]
```

```{r, echo=FALSE}
# Checking that the others listed are, indeed, LYZ high.
for (i in lyz.high) {
    out <- marker.info[[i]]
    stopifnot(out["LYZ", "median.AUC"] > 0.9)
}
```

Similarly, we can use the full set of effect sizes to define our own summary statistic if the precomputed measures are too coarse.
For example, we may be interested in markers that are upregulated against some percentage - say, 80% - of other clusters.
This improves the cluster specificity of the ranking by being more stringent than the median yet not as strigent as the minimum.
We achieve this by computing and sorting on the 20^th^ percentile of effect sizes, as shown below.

```{r}
stat <- rowQuantiles(as.matrix(chosen$full.AUC), p=0.2)
chosen[order(stat, decreasing=TRUE), 1:4] # just showing the basic stats for brevity.
```

## Handling blocking factors {#marker-batch}

Large studies may contain factors of variation that are known and not interesting (e.g., batch effects, sex differences).
If these are not modelled, they can interfere with marker gene detection - most obviously by inflating the variance within each cluster, but also by distorting the log-fold changes if the cluster composition varies across levels of the blocking factor.
To avoid these issues, we specify the blocking factor via the `block=` argument, as demonstrated below for the 416B data set.

```{r, results='asis', echo=FALSE}
extractFromPackage("lun-416b.Rmd", package="OSCA.workflows",
    chunk="clustering", objects="sce.416b")
```

```{r}
m.out <- scoreMarkers(sce.416b, colLabels(sce.416b), block=sce.416b$block)
```

For each gene, each pairwise comparison between clusters is performed separately in each level of the blocking factor - in this case, the plate of origin.
By comparing within each batch, we cancel out any batch effects so that they are not conflated with the biological differences between subpopulations.
The effect sizes are then averaged across batches to obtain a single value per comparison, using a weighted mean that accounts for the number of cells involved in the comparison in each batch.
A similar correction is applied to the mean log-expression and proportion of detected cells inside and outside each cluster.

```{r blocked-markers-416b, fig.height=6, fig.width=6, fig.cap="Distribution of expression values across clusters for the top potential marker genes from cluster 1 in the 416B dataset. Each point represents a cell and is colored by the batch of origin."}
demo <- m.out[["1"]] 
ordered <- demo[order(demo$median.logFC.cohen, decreasing=TRUE),]
ordered[,1:4]

plotExpression(sce.416b, features=rownames(ordered)[1:6],
    x="label", colour_by="block")
```

The `block=` argument works for all effect sizes shown above and is robust to differences in the log-fold changes or variance between batches.
However, it assumes that each pair of clusters is present in at least one batch.
In scenarios where cells from two clusters never co-occur in the same batch, the associated pairwise comparison will be impossible and is ignored during calculation of summary statistics.

<!--
### Using the `design=` argument

Another approach is to define a design matrix containing the batch of origin as the sole factor.
`findMarkers()` will then fit a linear model to the log-expression values, similar to the use of `r Biocpkg("limma")` for bulk RNA sequencing data [@ritchie2015limma].
This handles situations where multiple batches contain unique clusters, as comparisons can be implicitly performed via shared cell types in each batch.
There is also a slight increase in power when information is shared across clusters for variance estimation.

```{r}
# Setting up the design matrix (we remove intercept for full rank
# in the final design matrix with the cluster-specific terms).
design <- model.matrix(~sce.416b$block)
design <- design[,-1,drop=FALSE]

m.alt <- findMarkers(sce.416b, design=design, direction="up")
demo <- m.alt[["1"]]
demo[demo$Top <= 5,1:4]
```

The use of a linear model makes some strong assumptions, necessitating some caution when interpreting the results.
If the batch effect is not consistent across clusters, the variance will be inflated and the log-fold change estimates will be distorted.
Variances are also assumed to be equal across groups, which is not true in general.
In particular, the presence of clusters in which a gene is silent will shrink the residual variance towards zero, preventing the model from penalizing genes with high variance in other clusters.
Thus, we generally recommend the use of `block=` where possible.
-->

## Invalidity of $p$-values {#p-value-invalidity}

### From data snooping

Previous editions of this chapter used $p$-values from the tests corresponding to each effect size, e.g., Welch's $t$-test, the Wilcoxon ranked sum test.
While this is acceptable for ranking genes, the $p$-values themselves are statistically flawed and are of little use for inference.
This is because the DE analysis is performed on the same data used to obtain the clusters, which represents "data dredging" (also known as fishing or data snooping).
The hypothesis of interest - are there differences between clusters? - is formulated from the data, so we are more likely to get a positive result when we re-use the data set to test that hypothesis.

The practical effect of data dredging is best illustrated with a simple simulation.
We simulate i.i.d. normal values, perform $k$-means clustering and test for DE between clusters of cells with `findMarkers()`.
The resulting distribution of $p$-values is heavily skewed towards low values (Figure \@ref(fig:pval-dist)).
Thus, we can detect "significant" differences between clusters even in the absence of any real substructure in the data.
This effect arises from the fact that clustering, by definition, yields groups of cells that are separated in expression space.
Testing for DE genes between clusters will inevitably yield some significant results as that is how the clusters were defined.

```{r pval-dist, fig.cap="Distribution of $p$-values from a DE analysis between two clusters in a simulation with no true subpopulation structure."}
library(scran)
set.seed(0)
y <- matrix(rnorm(100000), ncol=200)
clusters <- kmeans(t(y), centers=2)$cluster
out <- findMarkers(y, clusters)
hist(out[[1]]$p.value, col="grey80", xlab="p-value")
```

For marker gene detection, this effect is largely harmless as the $p$-values are used only for ranking.
However, it becomes an issue when the $p$-values are used to define "significant differences" between clusters with respect to an error rate threshold.
Meaningful interpretation of error rates require consideration of the long-run behavior, i.e., the rate of incorrect rejections if the experiment were repeated many times.
The concept of statistical significance for differences between clusters is not applicable if clusters and their interpretations are not stably reproducible across (hypothetical) replicate experiments.

### Nature of replication {#false-replicates}

The naive application of DE analysis methods will treat counts from the same cluster of cells as replicate observations.
This is not the most relevant level of replication when cells are derived from the same biological sample (i.e., cell culture, animal or patient).
DE analyses that treat cells as replicates fail to properly model the sample-to-sample variability [@lun2017overcoming].
The latter is arguably the more important level of replication as different samples will necessarily be generated if the experiment is to be replicated.
Indeed, the use of cells as replicates only masks the fact that the sample size is actually one in an experiment involving a single biological sample.
This reinforces the inappropriateness of using the marker gene $p$-values to perform statistical inference.

We strongly recommend selecting some markers for use in validation studies with an independent replicate population of cells.
A typical strategy is to identify a corresponding subset of cells that express the upregulated markers and do not express the downregulated markers.
Ideally, a different technique for quantifying expression would also be used during validation, e.g., fluorescent _in situ_ hybridisation or quantitative PCR.
This confirms that the subpopulation genuinely exists and is not an artifact of the scRNA-seq protocol or the computational analysis.

## Further comments

One consequence of the DE analysis strategy is that markers are defined relative to subpopulations in the same dataset.
Biologically meaningful genes will not be detected if they are expressed uniformly throughout the population, e.g., T cell markers will not be detected if only T cells are present in the dataset.
In practice, this is usually only a problem when the experimental data are provided without any biological context - certainly, we would hope to have some _a priori_ idea about what cells have been captured.
For most applications, it is actually desirable to avoid detecting such genes as we are interested in characterizing heterogeneity  within the context of a known cell population.
Continuing from the example above, the failure to detect T cell markers is of little consequence if we already know we are working with T cells.
Nonetheless, if "absolute" identification of cell types is necessary, we discuss some strategies for doing so in Chapter \@ref(cell-type-annotation).

Alternatively, marker detection can be performed by treating gene expression as a predictor variable for cluster assignment.
For a pair of clusters, we can find genes that discriminate between them by performing inference with a logistic model where the outcome for each cell is whether it was assigned to the first cluster and the lone predictor is the expression of each gene.
Treating the cluster assignment as the dependent variable is more philosophically pleasing in some sense, as the clusters are indeed defined from the expression data rather than being known in advance.
(Note that this does not solve the data snooping problem.)
In practice, this approach effectively does the same task as a Wilcoxon rank sum test in terms of quantifying separation between clusters.
Logistic models have the advantage in that they can easily be extended to block on multiple nuisance variables, though this is not typically necessary in most use cases.
Even more complex strategies use machine learning methods to determine which features contribute most to successful cluster classification, but this is probably unnecessary for routine analyses.

## Session Info {-}

```{r sessionInfo, echo=FALSE, results='asis'}
prettySessionInfo()
```
